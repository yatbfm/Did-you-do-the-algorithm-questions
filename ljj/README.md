## My algorithm question source

- 代码随想录：https://programmercarl.com
- LeetCode 热题 100：https://leetcode.cn/studyplan/top-100-liked/
- CodeTop：https://codetop.cc/home

## My git commit message template

1. 提交源码

```shell
feat([题目编号][题目名称]): 完成代码实现
```

举例：feat(704. 二分查找): 完成代码实现

2. 提交文档

```shell
docs([题目编号][题目名称]): 添加题目解析与解题思路
```

举例：docs(704. 二分查找): 添加题目解析与解题思路

3. 提交进度更新

```
chore(progress): [题目编号][题目名称] -> [进度状态]
```

举例：chore(progress): [704. 二分查找] -> ✅

## My algorithm question details

- **题目名称**
- **相关标签**
- **平台**
- **难度**
- **进度**：当前的刷题进度，使用符号表示，`✅`表示完成，`⏳`表示正在解答，`❌`表示未解。

> 鄙人目前主要参考《代码随想录》\~\~\~，后续再调整目录结构。

## 数组

| 题目名称                                                     | 相关标签                                 | 平台      | 难度 | 进度 |
| ------------------------------------------------------------ | ---------------------------------------- | --------- | ---- | ---- |
| [704. 二分查找](https://leetcode.cn/problems/binary-search/) | `数组`，`二分查找`                       | leetcode  | 简单 | ✅    |
| [27. 移除元素](https://leetcode.cn/problems/remove-element/) | `数组`，`双指针`                         | leetcode  | 简单 | ✅    |
| [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/) | `数组`，`双指针`，`排序`                 | leetcode  | 简单 | ✅    |
| [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) | `数组`，`二分查找`，`前缀和`，`滑动窗口` | leetcode  | 中等 | ✅    |
| [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/) | `数组`，`矩阵`，`模拟`                   | leetcode  | 中等 | ✅    |
| [58. 区间和（第九期模拟笔试）](https://kamacoder.com/problempage.php?pid=1070) | `数组`                                   | kamacoder |      | ⏳    |
| [44. 开发商购买土地](https://kamacoder.com/problempage.php?pid=1044) | `数组`                                   | kamacoder |      | ⏳    |

## 链表

| 题目名称                                                     | 相关标签                   | 平台     | 难度 | 进度 |
| ------------------------------------------------------------ | -------------------------- | -------- | ---- | ---- |
| [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/) | `递归`，`链表`             | leetcode | 简单 | ✅    |
| [707. 设计链表](https://leetcode.cn/problems/design-linked-list/) | `设计`，`链表`             | leetcode | 中等 | ✅    |
| [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/) | `递归`，`链表`             | leetcode | 简单 | ✅    |
| [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) | `递归`，`链表`             | leetcode | 中等 | ✅    |
| [19. 删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/) | `链表`，`双指针`           | leetcode | 中等 | ✅    |
| [面试题 02.07.链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/) | `哈希表`，`链表`，`双指针` | leetcode | 简单 | ✅    |
| [ 142.环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/description/) | `哈希表`，`链表`，`双指针` | leetcode | 中等 | ✅    |

## 哈希表

| 题目名称                                                     | 相关标签                                       | 平台     | 难度 | 进度 |
| ------------------------------------------------------------ | ---------------------------------------------- | -------- | ---- | ---- |
| [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/) | `哈希表`，`字符串`，`排序`                     | leetcode | 简单 | ✅    |
| [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/) | `数组`，`哈希表`，`双指针`，`二分查找`，`排序` | leetcode | 简单 | ✅    |
| [202. 快乐数](https://leetcode.cn/problems/happy-number/description/) | `哈希表`，`数学`，`双指针`                     | leetcode | 简单 | ✅    |
| [1. 两数之和](https://leetcode.cn/problems/two-sum/description/) | `数组`，`哈希表`                               | leetcode | 简单 | ✅    |
| [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/description/) | `数组`，`哈希表`                               | leetcode | 中等 | ✅    |
| [383. 赎金信](https://leetcode.cn/problems/ransom-note/description/) | `哈希表`，`字符串`，`计数`                     | leetcode | 简单 | ✅    |
| [15. 三数之和](https://leetcode.cn/problems/3sum/description/) | `数组`，`双指针`，`排序`                       | leetcode | 中等 | ✅    |
| [18. 四数之和](https://leetcode.cn/problems/4sum/description/) | `数组`，`双指针`，`排序`                       | leetcode | 中等 | ✅    |

## 字符串

| 题目名称                                                     | 相关标签                         | 平台      | 难度 | 进度 |
| ------------------------------------------------------------ | -------------------------------- | --------- | ---- | -- |
| [344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/) | `双指针`，`字符串`               | leetcode  | 简单 | ✅  |
| [541. 反转字符串II](https://leetcode.cn/problems/reverse-string-ii/description/) | `双指针`，`字符串`               | leetcode  | 简单 | ✅  |
| [54. 替换数字（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1064) | `字符串`                         | kamacoder |      | ✅  |
| [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/) | `双指针`，`字符串`               | leetcode  | 中等 | ✅  |
| [55. 右旋字符串(第八期模拟笔试)](https://kamacoder.com/problempage.php?pid=1065) | `字符串`                         | kamacoder |      | ✅  |
| [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/) | `双指针`，`字符串`，`字符串匹配` | leetcode  | 简单 | ⏳   |
| [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/) | `字符串`，`字符串匹配`           | leetcode  | 简单 | ⏳   |

**KMP(Knuth-Morris-Pratt)**：一种用于字符串匹配的高效算法，能够在 $O(m+n)$ 的时间复杂度内完成主串和模式串的匹配，其中 $n$ 是主串长度，$m$ 是模式串长度。核心思想是**利用已经匹配的部分信息，避免重复匹配主串中的字符，减少比较次数。**

前缀表：$aabaaf$

| 子串     | 后缀                           | 后缀                          | 值   |
| -------- | ------------------------------ | ----------------------------- | ---- |
| $a$      | -                              | -                             | 0    |
| $aa$     | $a$                            | $a$                           | 1    |
| $aab$    | $a$,$aa$                       | $b$,$ab$                      | 0    |
| $aaba$   | $a$,$aa$,$aab$                 | $a$,$ba$,$aba$                | 1    |
| $aabaa$  | $a$,$aa$,$aab$,$aaba$          | $a$,$aa$,$baa$,$abaa$         | 2    |
| $aabaaf$ | $a$,$aa$,$aab$,$aaba$,$aabaaf$ | $f$,$af$,$aaf$,$baaf$,$abaaf$ | 0    |

对应就是：

| a    | a    | b    | a    | a    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 0    | 1    | 2    |

**待完善...**

## 双指针法

略

## 栈与队列

| 题目名称                                                     | 相关标签                                                     | 平台     | 难度 | 进度 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | ---- | ---- |
| [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/) | `栈`，`设计`，`队列`                                         | leetcode | 简单 | ✅    |
| [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/description/) | `栈`，`设计`，`队列`                                         | leetcode | 简单 | ✅    |
| [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/) | `栈`，`字符串`                                               | leetcode | 简单 | ✅    |
| [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/) | `栈`，`字符串`                                               | leetcode | 简单 | ✅    |
| [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/) | `栈`，`数组`，`数学`                                         | leetcode | 中等 | ✅    |
| [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/) | `队列`，`数组`，`滑动窗口`，`单调队列`，`堆(优先队列)`       | leetcode | 困难 | ✅    |
| [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/) | `数组`，`哈希表`，`分治`，`桶排序`，`计数`，`快速选择`，`排序`，`堆(优先队列)` | leetcode | 中等 | ✅    |

## 二叉树

| 题目名称                                                     | 相关标签                                               | 平台     | 难度 | 进度 |
| ------------------------------------------------------------ | ------------------------------------------------------ | -------- | ---- | ---- |
| [144.  二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) | `栈`，`树`，`深度优先搜索`，`二叉树`                   | leetcode | 简单 | ✅    |
| [145.  二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/) | `栈`，`树`，`深度优先搜索`，`二叉树`                   | leetcode | 简单 | ✅    |
| [94.  二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/) | `栈`，`树`，`深度优先搜索`，`二叉树`                   | leetcode | 简单 | ✅    |
| [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/) | `树`，`广度优先搜索`，`二叉树`                         | leetcode | 中等 | ✅    |
| [107. 二叉树的层次遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/) | `树`，`广度优先搜索`，`二叉树`                         | leetcode | 中等 | ✅    |
| [199.  二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/) | `树`，`深度优先搜索`，`广度优先搜索`，`二叉树`         | leetcode | 中等 | ✅    |
| [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/) | `树`，`深度优先搜索`，`广度优先搜索`，`二叉树`         | leetcode | 简单 | ✅    |
| [429. N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/) | `树`，`广度优先搜索`                                   | leetcode | 中等 | ✅    |
| [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/) | `树`，`深度优先搜索`，`广度优先搜索`，`二叉树`         | leetcode | 中等 | ✅    |
| [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/) | `树`，`深度优先搜索`，`广度优先搜索`，`链表`，`二叉树` | leetcode | 中等 | ✅    |
| [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/) | `树`，`深度优先搜索`，`广度优先搜索`，`链表`，`二叉树` | leetcode | 中等 | ✅    |
| [104.  二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/) | `树`，`深度优先搜索`，`广度优先搜索`，`二叉树`         | leetcode | 简单 | ✅    |
| [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/) | `树`，`深度优先搜索`，`广度优先搜索`，`二叉树`         | leetcode | 简单 | ✅    |

常见二叉树类型：**满二叉树**、**完全二叉树**、**二叉搜索树**、**平衡二叉搜索树**。

存储方式：

- 链式存储
- 线性存储

遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）：中左右
  - 中序遍历（递归法，迭代法）：左中右
  - 后序遍历（递归法，迭代法）：左右中
- 广度优先遍历
  - 层次遍历（迭代法）

### 二叉树定义

TreeNode.java：

```java
class TreeNode<T> {
    T val;
    TreeNode<T> left;
    TreeNode<T> right;

    TreeNode() {}

    TreeNode(T val) {
        this.val = val;
    }

    TreeNode(T val, TreeNode<T> left, TreeNode<T> right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

#### 前序遍历

递归版：

```java
// 前序遍历: 根 -> 左 -> 右
public List<T> preorderTraversal(TreeNode<T> root) {
    List<T> result = new ArrayList<>();
    preorder(root, result);
    return result;
}
private void preorder(TreeNode<T> root, List<T> result) {
    if (root == null) {
        return;
    }
    result.add(root.val);        // 访问根节点
    preorder(root.left, result); // 遍历左子树
    preorder(root.right, result);// 遍历右子树
}
```

非递归版（迭代版）：

```java
public List<Integer> preorderTraversalIterative(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        result.add(node.val);
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left);
    }
    return result;
}
```

#### 中序遍历

递归版：

```java
// 中序遍历: 左 -> 根 -> 右
public List<T> inorderTraversal(TreeNode<T> root) {
    List<T> result = new ArrayList<>();
    inorder(root, result);
    return result;
}
private void inorder(TreeNode<T> root, List<T> result) {
    if (root == null) {
        return;
    }
    inorder(root.left, result);  // 遍历左子树
    result.add(root.val);        // 访问根节点
    inorder(root.right, result); // 遍历右子树
}
```

非递归版（迭代版）：

```java
public List<Integer> inorderTraversalIterative(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            cur = stack.pop();
            result.add(cur.val);
            cur = cur.right;
        }
    }
    return result;
}
```

#### 后序遍历

递归版：

```java
// 后序遍历: 左 -> 右 -> 根
public List<T> postorderTraversal(TreeNode<T> root) {
    List<T> result = new ArrayList<>();
    postorder(root, result);
    return result;
}
private void postorder(TreeNode<T> root, List<T> result) {
    if (root == null) {
        return;
    }
    postorder(root.left, result);  // 遍历左子树
    postorder(root.right, result); // 遍历右子树
    result.add(root.val);          // 访问根节点
}
```

非递归版（迭代版）：

```java
public List<Integer> postorderTraversalIterative(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        result.add(node.val);
        if (node.left != null) stack.push(node.left);
        if (node.right != null) stack.push(node.right);
    }
    Collections.reverse(result);
    return result;
}
```

#### 层序遍历

递归版：

```java
public List<Integer> levelorderTraversal(TreeNode root) {
    List<List<Integer>> resList = new ArrayList<>();
    List<Integer> result = new ArrayList<>();
    levelorder(root, resList, 0);
    for (List<Integer> level : resList) {
        result.addAll(level);
    }
    return result;
}
private void levelorder(TreeNode root, List<List<Integer>> resList, int level) {
    if (root == null) return;
    level++;
    if (resList.size() < level) {
        List<Integer> item = new ArrayList<>();
        resList.add(item);
    }
    resList.get(level - 1).add(root.val);
    levelorder(root.left, resList, level);
    levelorder(root.right, resList, level);
}
```

非递归版（迭代版）：

```java
public List<Integer> levelorderTraversalIterative(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Deque<TreeNode> deque = new ArrayDeque<>();
    deque.offer(root);
    while (!deque.isEmpty()) {
        List<Integer> items = new ArrayList<>();
        int size = deque.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = deque.poll();
            items.add(node.val);
            if (node.left != null) deque.offer(node.left);
            if (node.right != null) deque.offer(node.right);
        }
        result.addAll(items);
    }
    return result;
}
```

验证：

```java
//       1
//      / \
//     2   3
//    / \
//   4   5
TreeNode root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

// 创建遍历器实例
TreeTraversal traversal = new TreeTraversal();

// 测试前序遍历 (预期结果: 1,2,4,5,3)
System.out.println("前序遍历(递归版): " + traversal.preorderTraversal(root));
System.out.println("前序遍历(迭代版): " + traversal.preorderTraversalIterative(root));

// 测试中序遍历 (预期结果: 4,2,5,1,3)
System.out.println("中序遍历(递归版): " + traversal.inorderTraversal(root));
System.out.println("中序遍历(迭代版): " + traversal.inorderTraversalIterative(root));

// 测试后序遍历 (预期结果: 4,5,2,3,1)
System.out.println("后序遍历(递归版): " + traversal.postorderTraversal(root));
System.out.println("后序遍历(迭代版): " + traversal.postorderTraversalIterative(root));
```

> 前序遍历(递归版): [1, 2, 4, 5, 3]
>
> 前序遍历(迭代版): [1, 2, 4, 5, 3]
>
> 中序遍历(递归版): [4, 2, 5, 1, 3]
>
> 中序遍历(迭代版): [4, 2, 5, 1, 3]
>
> 后序遍历(递归版): [4, 5, 2, 3, 1]
>
> 后序遍历(迭代版): [4, 5, 2, 3, 1]
>
> 层序遍历(递归版): [1, 2, 3, 4, 5]
>
> 层序遍历(迭代版): [1, 2, 3, 4, 5]

## 回溯算法

## 动态规划

## 单调栈

## 图论

